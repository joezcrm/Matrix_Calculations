#ifndef MATRIX_OPERATIONS_H
#define MATRIX_OPERATIONS_H
#include "balance_tree.h"
#include <iostream>
#include <thread>
#include <future>
#include <vector>

typedef unsigned int MInt;
typedef long double LDouble;
typedef LDouble* LDPtr;

// If absolute number of a number is less than NUMERIC_ERROR, the number 
//		is considered as zero
#define NUMERIC_ERROR 1e-15L
// The number of threads to use in calculations
#define NUMBER_OF_THREADING 3
// Summation of a list is performed by first summing all elements in each interval
//		and then sum the results up, in order to reduce numeric error
#define VECTOR_INTERVAL_SIZE 128

// Vector representation of a Householder matrix
// A Householder matrix is a matrix H such that
//		H = I - beta * v * transpose(v),
// where I is the identity matrix, v is a vector, and beta is a constant real number
// "*" represents related multiplications
// A Householder matrix is generated by a vector x such that (for example, using a
//		vector of length 6)
//				 __	   __
//				| -alpha |
//				|	0	 |	
//		H * x = |	0	 |
//				|	0	 |
//				|	0	 |
//				|__	0  __|
// Except for the first element of the vector, all the remaining elements are zeros
class Householder
{
private:
	// The overall dimension
	MInt h_Dim;
	// The location at which the Householder operation begins
	MInt h_Start;
	// The dimension of Householder sub-matrix
	MInt h_Size;
	// The vector that represents the Householder matrix
	LDPtr h_Vector;
	// Constant beta
	LDouble h_Beta;
	// Constant alpha
	LDouble h_Alpha;
	// Constructors call this methods
	void initialize(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation, MInt vSize, 
		MInt nStart, bool useCol);
public:
	// dMatrix, a matrix passed to generate the Householder matrix
	// colSize, the size of columns, or the number of rows
	// rowSize, the size of rows, or the number of columns
	// vLocation, the location of the row or column chosen
	// vSize, the size of dVector, has to <= colSize or <= rowSize
	// useCol, true if choose to use a column, false if use a row
	Householder(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation, MInt vSize, bool useCol);
	Householder(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation, MInt vSize,
		MInt nStart, bool useCol);
	// After declaration, should copy the value of another Householder to it
	// Should not use default Householder directly
	Householder();
	~Householder();
	// dMatrix, the pointer to a matrix
	// colSize, the size of each column vector
	// rowSize, the number of rows in the matrix
	// rowLocation, the location of column to apply Householder
	void leftMultiply(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt colLocation) const;
	// dMatrix, the pointer to a matrix
	// colSize, the number of columns
	// rowSize, the number of rows
	// colLocation, the location of row to apply Householder
	void rightMultiply(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt rowLocation) const;
	Householder& operator = (Householder& hOther);
	LDouble getAlpha();
};
typedef Householder* HousePtr;

// The class represents a Givens matrix, G,
// A Givens matrix is by a two-dimensional vector or two elements of a vector, x
// Such that,	 __   __
//				| alpha |
//		G x =   | 
//				|__	0 __|
class Givens
{
private:
	// Dimension of Givens matrix
	MInt g_Dim;
	LDouble g_Cos;
	LDouble g_Sin;
	// To change the element at the location of g_LocationK to be zero
	MInt g_LocationK;
	MInt g_LocationI;
public:
	// dMatrix, a 2D array of long double data
	// colSize, the size of column or the number of rows
	// rowSize, the size of row or the number of columns
	// vLocation, the location of vector within the matrix
	// locationK, a position within a vector
	// locationI, a position within a vector
	// locationK != locationK
	// useCol, true if use column, false if use row
	Givens(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation, 
		MInt locationK, MInt locationI, bool useCol);
	// After creation, should copy value of another Givens matrix to this
	// Should not use default Givens matrix directly
	Givens();
	~Givens();
	Givens& operator = (Givens& gOther);
	// Multiply a vector by a Givens matrix on left
	void leftMultiply(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation) const;
	// Multiply transpose of a vector by a Givens matrix on right
	void rightMultiply(LDPtr* dMatrix, MInt colSize, MInt rowSize, MInt vLocation) const;
};
typedef Givens* GivensPtr;


struct ThreadingDatta
{
	LDPtr* dMatrix;
	bool byHouse;
	HousePtr hPtr;
	GivensPtr gPtr;
	MInt minLocation;
	MInt maxLocation;
	MInt colSize;
	MInt rowSize;
};

typedef ThreadingDatta* TDataPtr;

// This class define some matrix operations on square matrix, including solving system of 
//		linear equations, finding Eigenvalues and Eigenvectors
// Methods of this class will modify matrix elements.
class DenseMatrix
{
private:
	// true, if the matrix is symmetric; false otherwise
	bool m_Symmetrical;
	// The number of thread to be used
	MInt m_Thread;
	// The size of the matrix 
	MInt m_Size;
	// A pointer to a 2D array representing a matrix, m_Matrix[i] represents column vector
	LDPtr* m_Matrix;
	// Tranfromation matrix
	LDPtr* m_TransMatrix;
	void clearMemory();
	// Initialization, all parameters are the same as the constructor
	void initialize(LDPtr* pMatrix, MInt nSize);
	// Solve a system of linear equations that have certain structure
	// The vector used to initialize the class cannot be nullptr, otherwise will throw
	// 	   std::invalid_argument upon a call of this method
	// Assuming non-zero elements exist only at upper-triple diagonal positions, for example
	// * * * 0 0 0 
	// 0 * * * 0 0
	// 0 0 * * * 0
	// 0 0 0 * * 0
	// 0 0 0 0 * *
	// 0 0 0 0 0 * 
	// The method is written for testing matrix operations on symmetric matrix
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	bool solveUpperTriDiagonal(LDPtr pVector, MInt nSize);
	// Solve a system of linear equations that have certain structure
	// The vector used to initialize the class cannot be nullptr, othersize will throw
	// 	   std::invalid_argument upon a call of this method
	// Assuming non-zero elements exists only at the middle tree diagonal positions, for example
	// * * 0 0 0 0
	// * * * 0 0 0
	// 0 * * * 0 0
	// 0 0 * * * 0
	// 0 0 0 * * *
	// 0 0 0 0 * *
	// The method is written for testing matrix operations on symmetric matrix
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	bool solveTriDiagonal(LDPtr pVector, MInt nSize);
	// Solve a system of linear equations that have certain structure
	// The vector used to initialize the class cannot be nullptr, othersize will throw
	// 	   std::invalid_argument upon a call of this method
	// Assuming non-zero elements exists only at the positions below the diagonal, for example
	// * 0 0 0 0 0
	// * * 0 0 0 0
	// * * * 0 0 0
	// * * * * 0 0
	// * * * * * 0
	// * * * * * *
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	bool solveLowerTriangle(LDPtr pVector, MInt nSize);
	// Soleve system of linear equations, assuming the matrix is upper triangle
	// for example
	// * * * * * *
	// 0 * * * * *
	// 0 0 * * * *
	// 0 0 0 * * *
	// 0 0 0 0 * *
	// 0 0 0 0 0 *
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	bool solveUpperTriangle(LDPtr pVector, MInt nSize);
	// Reduce a matrix to upper Hessenberg form, for exmaple
	// * * * * * *
	// * * * * * *
	// 0 * * * * *
	// 0 0 * * * *
	// 0 0 0 * * *
	// 0 0 0 0 * *
	void toUpperHessenberg();
	// Assuming matrix is symmetric positive defined
	// Find a lower triangle matrix, G, such that A = G * Transpose(G)
	// where A is the matrix
	// If not symmetric positive defined, will throw std::range_error
	bool choleskyDecompose();
	// Reduce a matrix to upper triangle form using Householder method, for exmaple
	// * * * * * *
	// 0 * * * * *
	// 0 0 * * * *
	// 0 0 0 * * *
	// 0 0 0 0 * *
	// 0 0 0 0 0 *
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	void toUpperTriangleByHouseholder(LDPtr pVector, MInt nSize);
	// Reduce a matrix to lower triangle form using Householder method, for example
	// * 0 0 0 0 0
	// * * 0 0 0 0
	// * * * 0 0 0
	// * * * * 0 0
	// * * * * * 0
	// * * * * * *
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	void toLowerTriangleByHouseholderAndSolve(LDPtr pVector, MInt nSize);
	// Multiply a matrix by a Householder matrix using multiple threads
	// The corresponding promises should be used to create the threads before passing to
	//		the method
	// Tow sets of threads will be created from left and right multiplication respectively
	// Parameters:
	//		leftMainPromise, rightMainPromise, threads will wait for results from the main thread
	//		rightThreadPromise, rightThreadPromise, main thread will will for results from threads
	//		pHMatrix, a pointer to Householder matrix
	//		leftStart, rightStart, the start location
	//		leftEnd, rightEnd, the ending location
	//		calcTrans, if true, will calculate the transformation matrix; otherwise
	//			not to calculate
	void multiplyByHouseholder(
		std::promise<TDataPtr>* leftMainPromise,
		std::promise<void>* leftThreadPromise,
		std::promise<TDataPtr>* rightMainPromise,
		std::promise<void>* rightThreadPromise,
		HousePtr pHMatrix,
		MInt leftStart,
		MInt leftEnd,
		MInt rightStart,
		MInt rightEnd,
		bool calcTrans);
	// Multiply the transformation matrix by a Givesn matrix using multiple threads
	// Promises should be used to create threads before passing to the method
	void multiplyByGivens(
		std::promise<TDataPtr>* leftMainPromise,
		std::promise<void>* leftThreadPromise,
		GivensPtr pGivens);
public:
	// Parameters:
	// pMatrix, a pointer to a 2-D array representing a matrix, and pMatrix[i] represents
	//		the ith column of the matrix, starting from 0; pMatrix cannot be nullptr and
	//		pMatrix[i] cannot be nullptr
	// nSize, the size of the matrix, size != 0
	// The constructor will throw std::invalid_argument or std::bad_alloc() if error occurs
	DenseMatrix(LDPtr* pMatrix, MInt nSize);
	~DenseMatrix();
	// Indicate that the matrix is a symmetric matrix and the matrix reduction will change
	//		accordingly
	// Parameter:
	// bSymmtrical, true if the matrix is sysmetric, false if using non-symmetric reductions
	void setSymmetrical(bool bSymmetrical);;
	// Reduce to real schur form using Francis QR method, for example
	// * * * * * *
	// * * * * * *
	// 0 0 * * * *
	// 0 0 0 * * *
	// 0 0 0 * * *
	// 0 0 0 0 0 *
	// There will two possible cases: 
	//		1, real Eigenvalues are stored on the diagonal positions
	//		2, 2x2 matrices, whose Eigenvalues are also Eigenvalues of the matrix under
	//			under consideration, are stored on the diagonal positions
	void schurDecomposeByFrancisQR();
	// Reduce to diagonal matrix using Symmetric QR, assuming the matrix is symmetric; 
	//		if the matrix is not symmetric, the resulting matrix will not be diagonal
	// For example:
	// * 0 0 0 0 0
	// 0 * 0 0 0 0
	// 0 0 * 0 0 0
	// 0 0 0 * 0 0
	// 0 0 0 0 * 0
	// 0 0 0 0 0 *
	// All Eigenvalues of symmetrical matrix are real numbers and are stored at the
	//		diagonal positions
	void schurDecomposeBySymmetricQR();
	// Solve system of linear equations using Cholesky decomposition
	// If find out that the matrix is not symmetric ang positively defined, the solving
	//		process will stop
	// The vector passed to the constructor cannot be nullptr.
	// If succeeded, the field s_Solved will set to true and s_PositiveDef will set to be true
	bool solvedByCholesky(LDPtr pVector, MInt nSize);
	// Solve system of linear equations using Householder reduction
	// The vector passed to the constructor cannot be nullptr
	// Parameter:
	//		pVector, a 1-D array representing a vector
	//		nSize, size of the vector
	// If the system of linear equations has solution, the method will return true and the
	//		solution will be stored in pVector
	bool solvedByHouseholder(LDPtr pVector, MInt nSize);
	// Set value of an element in matrix
	// Parameters:
	//		colPos, the position of column vector
	//		rowPos, the position of row vector
	//		dValue, the value to be set
	void setValue(MInt colPos, MInt rowPos, LDouble dValue);
	// Get value of an element from matrix
	// Parameters:
	//		colPos, the position of column vector
	//		rowPos, the position of row vector
	LDouble getValue(MInt colPos, MInt rowPos);

};

// This class define methods to solve least square problems and singular value decompose
// Any operations will modify values of matrix elements
class GeneralMatrix
{
private:
	// Transformation matrix on the left of singular value decompose
	LDPtr* m_LeftTransMatrix;
	// Transformation matrix on the right of singular value decompose
	LDPtr* m_RightTransMatrix;
	// Number of columns, or size of rows
	MInt m_RowSize;
	// Number of rows, or size or columns
	MInt m_ColSize;
	// A pointer to a 2-D array representing a matrix;
	LDPtr* m_Matrix;
	// Number of thread to used
	MInt m_Thread;
	// The method reduce a matrix to a form such that elements on the position of 
	//		(i, i) and (i, i + 1) are non-zeros; all other elements are zeros.
	// For example:
	// * * 0 0 0 0
	// 0 * * 0 0 0
	// 0 0 * * 0 0
	// 0 0 0 * * 0
	// 0 0 0 0 * *
	// 0 0 0 0 0 *
	// 0 0 0 0 0 0
	// This is the first step of singular value decompose
	void toUpperBiDiagonal();
	// Multiply a matrix by a Householder matrix using multiple threads
	// The corresponding promises should be used to create the threads before passing to
	//		the method
	// Parameters:
	//		mainPromise, threads will wait for results from the main thread
	//		threadPromise, main thread will will for results from threads
	//		pHouse, a pointer to Householder matrix
	//		nStart, the start location
	//		nEnd, the ending location
	//		byLeft, if true, multiply Householder on the left; otherwise, on right
	//		calcTrans, if true, will calculate the transformation matrix; otherwise
	//			not to calculate
	void multiplyByHouseholder(
		std::promise<TDataPtr>* mainPromise,
		std::promise<void>* threadPromise,
		HousePtr pHouse,
		MInt nStart,
		MInt nEnd,
		bool byLeft,
		bool calcTrans);
	// Multiply matrix by a Givens matrix
	// The promise should use to create threads before passing to the method
	// Parameters:
	//		mainPromise, threads will wait for results from the main thread
	//		threadPromise, main thread will will for results from threads
	//		pGivens, a pointer to Givens matrix
	//		byLeft, if true, multiply Householder on the left; otherwise, on right
	void multiplyByGivens(
		std::promise<TDataPtr>* mainPromise,
		std::promise<void>* threadPromise,
		GivensPtr pGivens,
		bool byLeft);
	void clearMemory();
public:
	// Parameters:
	// pMatrix, a pointer to a 2-D array representing a matrix; if pMatrix[i] is nullptr,
	// 	   all elements on the column are set to zeros
	// colSize, the number of rows in the matrix, or the column size
	// rowSize, the number of columns in the matrix, or the row size; rowSize <= colSize 	   
	// Methods of the class will modify elements of the matrix
	// In case of failure, throw std::invalid_argument() or std::bad_alloc()
	GeneralMatrix(LDPtr* pMatrix, MInt colSize, MInt rowSize);
	~GeneralMatrix();
	// The method first reduce a matrix to upper triangle form, for example
	// * * * * 0 0
	// 0 * * * 0 0
	// 0 0 * * 0 0
	// 0 0 0 * 0 0
	// 0 0 0 0 0 0
	// 0 0 0 0 0 0
	// 0 0 0 0 0 0
	// and solve a system of linear equations with some rank. In the above example, rank = 4.
	bool solveLeastSquare(LDPtr pVector, MInt nSize);
	// Assuming rank = row size, and reduce to upper triangle form, for example
	// * * * * * *
	// 0 * * * * *
	// 0 0 * * * *
	// 0 0 0 * * *
	// 0 0 0 0 * *
	// 0 0 0 0 0 *
	// 0 0 0 0 0 0
	// and solve a system of linear equations
	bool solveLeastSquareFullRank(LDPtr pVector, MInt nSize);
	// First call toUpperBiDiagonal() to reduce the matrix to a certain form, for example
	// * * 0 0 0 0
	// 0 * * 0 0 0
	// 0 0 * * 0 0
	// 0 0 0 * * 0
	// 0 0 0 0 * *
	// 0 0 0 0 0 *
	// 0 0 0 0 0 0
	// Then, reduce to a form that only diagonal positions contain non-zero value, for example
	// * 0 0 0 0 0
	// 0 * 0 0 0 0
	// 0 0 * 0 0 0
	// 0 0 0 * 0 0
	// 0 0 0 0 * 0
	// 0 0 0 0 0 *
	// 0 0 0 0 0 0
	// All singular values are stored on the diagonal positions
	void singularValueDecompose();
	// Set value of an element in matrix
	// Parameters:
	//		colPos, the position of column vector
	//		rowPos, the position of row vector
	//		dValue, the value to be set
	void setValue(MInt colPos, MInt rowPos, LDouble dValue);
	// Get value of an element from matrix
	// Parameters:
	//		colPos, the position of column vector
	//		rowPos, the position of row vector
	LDouble getValue(MInt colPos, MInt rowPos);
};
#endif